\section{Core Language}


The user of our system instructs a single robot which moves in a world
consisting of several connected rooms. These rooms contain a number of items,
which can have different properties; for simplicity we consider here different
colors and shapes. The robot can modify this world by moving to a location
containing an item, by picking up and dropping items, possibly at different
locations.

\subsection{Syntax and Semantics}


While the abstract world in which our robot operates is relatively simple,
the core language used to instruct the robot is sufficiently expressive to
allow for interesting scenarios. \autoref{fig:core-syntax} illustrates the
syntax of the core language.
\todo[inline]{(Eva) I have based this on syntaxsemantics.md. That document does not
have the select statement though. Do we have this?}
\begin{figure}[t]
  Control flow:
  \begin{lstlisting}
  Stmt -> Act | Stmt; Stmt
  Stmt -> repeat n times Stmt
  Stmt -> foreach point in Area Stmt
  \end{lstlisting}

  Actions:
  \begin{lstlisting}
  Act -> visit Loc avoiding Loc | pick Itm | drop Itm
  Act -> select Itm
  Act -> strict Act
  \end{lstlisting}

  Locations:
  \begin{lstlisting}
  Area -> Area containing Itm
  Area -> Area and Area | Area or Area
  Area -> world   // every point on the map
  Area -> Pnt | [Pnt, Pnt, ..., Pnt]
  Pnt -> [x, y]
  \end{lstlisting}

  Items:
  \begin{lstlisting}
  Itm -> item | item Fltr
  Fltr -> Fltr and Fltr | Fltr or Fltr | not Fltr
  Fltr -> has color C | has shape S
  C -> red | blue | green | yellow
  S -> triangle | square | circle
  \end{lstlisting}
  \caption{Syntax of core language (subset)}
  \label{fig:core-syntax}
\end{figure}
In addition, our language also allows to express sets of areas and
conditionals which we omit here for space reasons.

\begin{example}\label{ex:core-syntax}
\todo[inline]{RM: a figure showing the world?}
Before giving the semantics, we provide some example programs in the core language.
\begin{itemize}
\item Go to a red item and pick it up $\ldots$
\begin{lstlisting}
visit world containing item has color red ; 
pick item has color red
\end{lstlisting}
$\ldots$ but avoid all circular items along the way
\begin{lstlisting}
visit world containing item has color red 
    avoiding world containing item has shape circle ;
pick item has color red
\end{lstlisting}

\item Gather all red items
\begin{lstlisting}
foreach point in world containing item has color red 
    { visit point; pick item has color red }
\end{lstlisting}
\todo[inline]{RM: I think we have gone for really complicated examples}

\item Drop an item to any field that contains both a red and a circle-shaped item
(possibly the same item):
\begin{lstlisting}
foreach point in {world containing item has color red} and
{world containing item has shape circle } {visit point; drop item}
\end{lstlisting}

\item If possible, form a horizontal line on the floor out of all items robot
    currently has and starting at robot's current position:
    \begin{lstlisting}
strict {while robot has item {drop item; move right}};
strict {while robot has item {drop item; move left}}
    \end{lstlisting}

\item Keep bringing circle-shaped items to room1 until there is a red item in room1:
    \todo[inline]{(Eva) I have thought to not include while in the syntax, as everything
    we include we need to explain which takes space. This example uses it though.}
    \begin{lstlisting}
while not { item has color red at room1}
  {visit {world containing item has shape circle} minus room1;
pick item has shape circle; visit room1; drop item has shape circle}
    \end{lstlisting}
\end{itemize}
\end{example}



Intuitively, the semantics of the core language maps a sentence to a \emph{temporal goal}
in a logical language over the grid world.
The model of our world consists of a tuple $(M, I, r)$ where
$M$ is a two-dimensional grid, $I$ is the set of items, and $r$ is the robot.
Each item $i \in I$ is has an associated color, shape and a unique identifier.
The robot has a position in $M$ and holds a set of items. All items are either held by
the robot, or can be mapped to a position in $M$ ($pos: i \in I \to M$).

The propositions of the logical language specify either sets of items or sets of points.
The syntactic class Items is mapped to sets of items and Locations are mapped to sets of points. 
Propositions can be combined using Boolean operations as usual.
The valuations to all propositions define the world.

Actions define how the state of the world is updated through actions performed by the robot.
Some actions are ``two-state'' and specify a transformation between a ``before'' state and an
``after'' state.
For example, ``$\pick\ i$'' changes the world from a state where there is an item $i$ in the
current position of the robot to a world in which the item is being carried by the robot.

Finally, the \emph{temporal} action $\visit\ T\ \avoiding\ A$ defines the temporal
A capability such as $\pick$ or $\drop$ defines a two-state predicate which updates the world.
The capability $\visit\ T\ \avoiding\ A$ defines a temporal goal, written in linear
temporal logic as $\until{\lnot A}{T}$, which asks to reach some point in $T$ while avoiding
all points in $A$. 




The semantics of our core language is summarized in~\autoref{fig:core-semantics}.
\todo[inline]{(Eva) To be continued... Not sure yet how to present this.}

\begin{figure}[t]
  \begin{align*}
  \sem{item Fltr}{\{i \in I: Filter(i) == true \}} \\
  \sem{has color c}{i.color == c}\\
  ...
  \end{align*}
  \caption{Semantics of the core language}
  \label{fig:core-semantics}
\end{figure}

\begin{example}
%
Consider the commands in Example~\ref{ex:core-syntax}.
\end{example}

\subsection{Semantic Parsing}

While each sentence in the core language unambiguously defines a goal, the core language itself is
a restricted (context-free) language that is not suitable for end users. 
We use a semantic parser \cite{CITE,CITE} to map an utterance in natural language to one or more sentences
in the core language, together with confidence levels.
Unlike a parser for a context-free language, a semantic parser needs to perform linguistic processing
to identify natural language phrases and map them to tokens.
Moreover, since natural language is ambiguous, the parser may map an utterance to multiple sentences
in the core language.
We use the Sempre semantic parser \cite{CITE}, which can be configured to use multiple NLP backends (such as
the \todo[inline]{RM: which}) and which uses a statistical model to assign confidences to multiple parsed sentences.

\begin{example}
\todo[inline]{RM: an example of an ambiguous parse}
\end{example}

\subsection{Planner and User Feedback}

A sentence in the core language defines a temporal goal.
We use a planner for temporal goals \cite{Antlab}
to generate a (possibly reactive) plan for the robot in the world.
Currently, our planner is based on A* search \cite{Astar} but we can configure
a different planner such as a reactive planner for temporal specifications
(JoergsPlanner or LTLMOP \cite{LTLMOP} or Antlab \cite{Antlab}).

In our experience, A* search was fast and sufficient to find plans in the simulated world.
Fast planning is crucial for user interaction.
In case the semantic parser returns several alternatives, we rank order the alternatives
according to their confidence values and generate a plan for each of them.
We execute the plan in the simulated world to visually demonstrate to the user the effect of each
interpretation of the utterance.
The user can select the plan that best matches his or her intention. 
 


